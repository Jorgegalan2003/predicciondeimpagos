Códigos empleados en el Trabajo Fin de Grado de Jorge Galán para la ETSIT UPM, cuyo objetivo es el de la predicción de impagos en proyectos de electrificación rural de la Fundación Acciona.

En primer lugar, está clientes_y_ventas.py. Este código carga tres archivos CSV que contienen información sobre ventas, servicios y clientes. Tras verificar que los archivos existen, extrae las columnas clave, las renombra y realiza uniones entre las tablas para relacionar cada venta con su servicio correspondiente y, a su vez, con el cliente asociado. Finalmente, reorganiza las columnas resultantes (client_id, utility_id, sale_id) y guarda esta información consolidada en un nuevo archivo CSV llamado client_util_sale.csv
Después, se creo el módulo clientes_y_ventas_ordenado.py, que lo que hace es ordenar el CSV generado con el módulo anterior y ordenarlo  por cliente para que todas las ventas de cada cliente aparezcan de forma consecutiva.

Los módulos rates, quantity, nonPaymentPeriod, con_comunidad_y_país y amount añaden al CSV anterior las propiedades de ese mismo nombre al CSV. Toda esat funcionalidad se recoge en csv_completo.py, que hace simultáneamente todas las funcionalidades explicadas anteriormente.

Después, está el modulo filtro.py, que elimina todas aquellas ventas que tengan alguna de las variables independientes anteriormente mencionadas con valor NULL. El módulo definitivo.py realiza todas las funcionalidades explicadas hasta el momento, incluida este ultimo filtrado y además ordena las ventas de cada cliente por orden cronológico, de la más antigua a la más reciente.

Los siguientes scripts forman parte de un sistema completo para entrenar, evaluar y analizar modelos LSTM orientados a predecir el estado de pago de clientes (como "CORRECTO", "PENDIENTE_DE_PAGO" e "IMPAGO") a partir de datos de ventas y consumo. El flujo comienza con el entrenamiento y predicción mediante modelos LSTM como los de LSTM.py, LSTM_POR_PESOS.py y lstm_distribución_manual_de_pesos.py, que siguen una estructura similar: cargan datos de clientes, normalizan los valores de entrada, los dividen en entrenamiento y validación, y entrenan un modelo LSTM con PyTorch. Las diferencias radican en el tratamiento de las clases desbalanceadas: uno usa pesos por defecto, otro calcula pesos inversamente proporcionales a la frecuencia de las clases, y otro los asigna manualmente para enfatizar la detección de impagos. Se hizo una primera aproximación usando todos los clientes para tener una primera idea de qué método podría llegar a funcionar mejor, y se apreció que pesos inversos y pesos manuales tenían resultados similares.

Después, el módulo definitivo_con_estado_clientes.py calcula el estado de las ventas de un cliente y los almacena en el CSV bajo el nombre de state. Por su parte, state_and_days.py añade los días reales transcurridos entre ventas y venta de un cliente. Por último, esto se complementa con paymentPeriod.py, que añade a este último CSV esta variable que marca el periodo de pago de un ciliente según su tarifa.

Posteriormente, una vez se había comprobado que para esta caso de estudio el mejor de los escenarios planteados en el párrafo anterior era usar una distribución de pesos inversis a la frecuencia, se plantearon 4 escenarios en los que se trabajaría con los datos de Perú al ser los más desbalanceados: priorizar la Validation Loss usasndo pesos inversos y manuales, y priorizar el Recall de la clase Impago volviendo a usar las dos distintas distribuciones de pesos. Esta funcionalidad la dan los módulos predict_autoregresive.py, predict_autoregresive_pesos_manuales, prioritize_recall_pesos_inversos y prioritize_recall_pesos_manueales respectivamente. Los 4 módulos usan LSTM para entrenar el modelo y predecir el estado de las ventas, devolviendo el reporte de clasifificación de cada uno de los escenarios.

Los módulos beam_search.py y partial_teacher_forcing.py utilizan una LSTM con pesos inversos a la frecuencia para entrenar y evaluar el modelo aplicando las respectivas técnicas que dan nombre al módulo y cuyas explicaciones de los algoritmos se encuentran en el PDF del TFG. Por otro lado, está pesos_manuales_scheduled_sampling.py, que hace lo mismo que los anteriores pero aplicando la técnica de scheduled_sampling, que resultó tener mayor eficiencia usando pesos manuales que inversos, pero que en ningún moemto dio mejor rendimiento que los dos anteriores. Estos módulos seguían enfocados en la predicción del futuro estado de las ventas.

Ahora, procederemos a explicar los códigos relacionados con el segundo de los casos de estudio: la estimación de los días que tardará el cliente en volver a pagar.

 
